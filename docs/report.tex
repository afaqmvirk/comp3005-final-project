\documentclass[12pt]{article}
\usepackage[left=.6in,
right=.6in,
top=.6in,
bottom=.6in,]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage{graphicx}
\usepackage{listings}
\usepackage[normalem]{ulem}
\usepackage{enumitem}     
\definecolor{boxfill}{RGB}{49,175,255}
\definecolor{boxborder}{RGB}{0,0,0}

\usepackage{setspace}
\usepackage{booktabs}
\setlength{\extrarowheight}{2pt}

\renewcommand{\arraystretch}{1.25}


\usepgfplotslibrary{statistics}
\pgfplotsset{compat=1.18}

\lstset{
  basicstyle=\ttfamily\small,
  breaklines=true,
  frame=single,
  columns=fullflexible
}

\makeatletter
\newcommand{\skipitems}[1]{%
  \addtocounter{\@enumctr}{#1}%
}
\newcommand{\m}{\text{m}}
\newcommand{\dsp}[1]{\displaystyle{#1}}
\makeatother

\title{COMP 3005 Final Project Report}
\author{Afaq Virk, Raymond Liu}
\begin{document}

\begin{flushright}
COMP 3005 - Fall 2025

Database Management Systems

Final Project Report

Raymond Liu 101264487

Afaq Virk 101338854

\end{flushright}

\newpage
\section*{Table}

{\scriptsize
\begin{longtable}{|>{\raggedright\arraybackslash}p{0.32\textwidth}|
                         >{\raggedright\arraybackslash}p{0.32\textwidth}|
                         >{\raggedright\arraybackslash}p{0.32\textwidth}|}
\hline
\textbf{Requirement} & \textbf{Assumption} & \textbf{Representation in ER Model} \\
\hline

“The application will support three distinct categories of users—members, trainers, and administrative staff—each with specialized access privileges and clearly defined functional responsibilities.”
&
All human actors share the same core attributes (name, contact information, credentials) and differ only by role. Each user holds exactly one role at a time.
&
Entity \texttt{User} with PK \texttt{id} and attributes \texttt{email}, \texttt{password}, \texttt{first\_name}, \texttt{last\_name}, \texttt{date\_of\_birth}, \texttt{sex}, \texttt{phone}. Entity \texttt{Role} with values \emph{Member}, \emph{Trainer}, \emph{Admin}; FK \texttt{User.role}~$\rightarrow$~\texttt{Role.id}. \\
\hline

“A member should be able to register by providing personal information such as name, date of birth, gender, and contact details, and later manage or update these details as needed.”
&
The same personal-information structure applies to all user roles; registration and profile updates operate on a single user record.
&
Attributes listed above are stored once in \texttt{User}. No separate \emph{Member} table is introduced; the distinction is represented by the \texttt{role} foreign key. \\
\hline

“Members will have the ability to establish and track personalized fitness goals—such as achieving a target body weight or reducing body fat percentage—and store health metrics like height, weight, heart rate […]. These metrics should not overwrite previous entries but instead be recorded historically…”
&
Health metrics are modeled as individual time-stamped measurements. Goals are expressed in terms of these measurable metrics rather than free-form text. The owning user of a goal can be derived from the metric being targeted.
&
Entity \texttt{MetricType} (e.g., Weight, Body Fat \%). Entity \texttt{Metric} with PK \texttt{id}, FK \texttt{user\_id}~$\rightarrow$~\texttt{User.id}, FK \texttt{metric\_type}~$\rightarrow$~\texttt{MetricType.id}, attributes \texttt{value}, \texttt{logged\_date}. Entity \texttt{Goal} with PK \texttt{id}, FK \texttt{metric\_id}~$\rightarrow$~\texttt{Metric.id}, attribute \texttt{goal\_date}. Redundant \texttt{user\_id} is omitted from \texttt{Goal} to avoid transitive dependency. \\
\hline

“Members should be able to schedule, reschedule, or cancel personal training sessions […] and […] register for group fitness classes, subject to class capacity and schedule constraints. The system must ensure logical enforcement of business rules such as preventing overlapping bookings […] and verifying trainer availability before confirming any reservation.”
&
Actual classes/sessions are distinct from the availability slots defined by trainers. Sessions have a maximum capacity and may be attended by many members. Each member can enroll in a given session at most once.
&
Entity \texttt{Schedule} (trainer availability) with PK \texttt{id}, FK \texttt{trainer\_id}~$\rightarrow$~\texttt{User.id}, attributes \texttt{date}, \texttt{start\_time}, \texttt{end\_time}, FK \texttt{type}~$\rightarrow$~\texttt{ScheduleType.id}. Entity \texttt{Session} with PK \texttt{id}, FK \texttt{schedule\_id}~$\rightarrow$~\texttt{Schedule.id}, attributes \texttt{name}, \texttt{size}, \texttt{desc}, \texttt{location}, \texttt{sex\_restrict}. Associative entity \texttt{Enrollment} linking \texttt{User} (member) and \texttt{Session}, with PK \texttt{id}, FKs \texttt{session\_id}, \texttt{member\_id}, attribute \texttt{attended}, and \texttt{UNIQUE(session\_id, member\_id)}. \\
\hline


“Trainers should be able to specify their availability periods—either as recurring weekly slots or as individual time intervals—and update these schedules as needed. The system must prevent overlapping or inconsistent time slots for the same trainer…”
&
We store concrete time intervals; recurring availability patterns are handled at the application level by generating individual schedule rows. Overlap checks are enforced in application logic rather than as constraints in the ER model.
&
Entity \texttt{Schedule} as above, with each row representing one availability interval for a trainer, linked to \texttt{User} (trainer) and \texttt{ScheduleType}. No additional recurrence entity is modeled. \\
\hline

“Administrators will have the capability to manage room bookings to ensure that physical spaces—such as studios or training rooms—are properly allocated for classes and personal sessions, while avoiding conflicts in scheduling. They should also be able to oversee equipment management, including tracking the operational status of machines, logging maintenance issues, assigning repair tasks, and updating maintenance records once issues are resolved.”
&
Rooms and equipment are modeled explicitly; each piece of equipment belongs to at most one room and has one current status. Detailed maintenance history and automatic room–session conflict detection are treated as application-level responsibilities in this version.
&
Entities \texttt{Room} (PK \texttt{id}, attributes \texttt{name}, \texttt{capacity}), \texttt{EquipmentStatus} (PK \texttt{id}, attribute \texttt{type}), and \texttt{Equipment} (PK \texttt{id}, attributes \texttt{name}, FK \texttt{room\_id}~$\rightarrow$~\texttt{Room.id}, FK \texttt{status\_id}~$\rightarrow$~\texttt{EquipmentStatus.id}). Session locations are stored as a text attribute \texttt{location}. \\
\hline

“The administrative component should also handle billing and payment processes, where the system can generate bills for various services such as membership subscriptions, personal training sessions, or class enrollments. Payments are to be simulated rather than processed through real financial gateways; however, the system should maintain a consistent record of invoices […] and payment status…”
&
Bills may contain multiple services, and each service can appear on many bills. Only basic payment state is required (paid / unpaid); no sensitive payment details or external transaction identifiers are stored.
&
Entity \texttt{Service} for billable offerings. Entity \texttt{Bill} with PK \texttt{id}, FKs \texttt{admin\_id} and \texttt{member\_id} referencing \texttt{User}, attributes \texttt{date}, \texttt{paid}. Associative entity \texttt{Item} with PK \texttt{id}, FKs \texttt{bill\_id} and \texttt{service\_id}, and attribute \texttt{quantity} representing line items on a bill. \\
\hline

\end{longtable}
} % end scriptsize


% ---------------------------------------------------------------
% Normalization Section
% ---------------------------------------------------------------

\section*{Normalization (2NF and 3NF)}

All relations in the system use a single surrogate primary key (\texttt{id}). Therefore, no table has a composite primary key, and no non-key attribute can depend on part of a composite key. This implies that every relation satisfies \textbf{Second Normal Form (2NF)}.

To verify \textbf{Third Normal Form (3NF)}, we consider functional dependencies within each relation. For all tables except \texttt{Goal}, every non-key attribute depends directly and only on the primary key. Foreign keys (such as \texttt{role}, \texttt{metric\_type}, \texttt{schedule\_id}, \texttt{room\_id}) point to other relations, but do not determine additional non-key attributes within the same table, so they do not introduce transitive dependencies.

\subsection*{Initial Violation in \texttt{Goal} and Correction}

In the initial design, the \texttt{Goal} relation was defined as:
\[
\texttt{Goal(id, user\_id, metric\_id, goal\_date)}.
\]
The \texttt{Metric} relation has the form:
\[
\texttt{Metric(id, user\_id, \dots)},
\]
which implies the functional dependency
\[
\texttt{metric\_id} \rightarrow \texttt{user\_id}.
\]
Combining this with the primary key of \texttt{Goal} yields the transitive dependency
\[
\texttt{id} \rightarrow \texttt{metric\_id} \rightarrow \texttt{user\_id},
\]
so the non-key attribute \texttt{user\_id} depends on another non-key attribute \texttt{metric\_id}. This violates 3NF.

To restore 3NF, we removed the redundant attribute \texttt{user\_id} from \texttt{Goal}, giving:
\[
\texttt{Goal(id, metric\_id, goal\_date)}.
\]
The user associated with a goal is now obtained by joining \texttt{Goal.metric\_id} to \texttt{Metric.id} and then \texttt{Metric.user\_id}. In the revised relation, all non-key attributes depend solely on the primary key \texttt{id}, and there are no non-key~$\rightarrow$~non-key dependencies.

With this correction, \textbf{all relations in the Health and Fitness Club schema are normalized to 2NF and 3NF}, ensuring minimal redundancy and clear functional dependencies throughout the design.


\section*{Object-Relational Mapping (ORM) Usage}

We model role, metric\_type, schedule\_type, and equipment\_status as separate lookup entities to support data integrity, potential extension with additional attributes, and flexible configuration without changing the main schema. Simple static domains like sex and sex\_restrict are implemented as CHECK-constrained attributes instead of separate entities.

We used SQLAlchemy's Declarative ORM to map Python classes to relational tables and to express relationships and constraints directly in code. A single shared base class is defined with \texttt{declarative\_base()}, and each entity declares its table name, columns, constraints, and relationships. This allows us to perform type-safe CRUD operations, joins, and cascades using Pythonic APIs instead of writing raw SQL for common operations. Relationships (e.g., one-to-many between \texttt{User} and \texttt{Metric}) are modeled with \texttt{relationship(...)} along with \texttt{back\_populates} for bidirectional navigation, and we use options such as \texttt{cascade="all, delete-orphan"} to enforce lifecycle rules.

The application layer interacts with the database through a SQLAlchemy \texttt{Session}. Typical patterns include querying with \texttt{session.query(...).filter\_by(...).order\_by(...)}; creating domain objects, calling \texttt{session.add(...)} and \texttt{session.commit()}; performing relational joins for cross-entity views; and deleting records with transactional rollback on error. This approach keeps business logic in Python while the ORM translates it into efficient SQL.

\begin{lstlisting}[language=Python, caption={Example SQLAlchemy model mapping}]
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class User(Base):
    __tablename__ = 'user'
    id = Column(Integer, primary_key=True)
    email = Column(String(255), nullable=False, unique=True)
    first_name = Column(String(100), nullable=False)
    last_name = Column(String(100), nullable=False)
    role = Column(Integer, ForeignKey('role.id'), nullable=False)

    role_obj = relationship("Role", back_populates="users")
    metrics = relationship("Metric", back_populates="user",
                           cascade="all, delete-orphan")
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={Typical ORM query/CRUD usage}]
# Recent metrics for a member
recent = (session.query(Metric)
          .filter_by(user_id=user.id)
          .order_by(Metric.logged_date.desc())
          .limit(5)
          .all())

# Create and commit a new metric
new_metric = Metric(user_id=user.id, metric_type=metric_type_id, value=Decimal("72.5"))
session.add(new_metric)
session.commit()

# Join across relationships to see upcoming sessions
upcoming = (session.query(Enrollment)
            .join(Session)
            .join(Schedule)
            .filter(Enrollment.member_id == user.id, Schedule.date >= date.today())
            .order_by(Schedule.date, Schedule.start_time)
            .all())
\end{lstlisting}

\paragraph{Major mapped entities}
\begin{itemize}[nosep]
  \item Role, User
  \item Service, Bill, Item
  \item MetricType, Metric, Goal
  \item Room, EquipmentStatus, Equipment
  \item ScheduleType, Schedule, Session, Enrollment
\end{itemize}

\end{document}
