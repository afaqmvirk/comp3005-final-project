\documentclass[12pt]{article}
\usepackage[left=1in,
right=1in,
top=1in,
bottom=1in,]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{graphicx}
\usepackage{listings}
\usepackage[normalem]{ulem}
\usepackage{enumitem}     
\definecolor{boxfill}{RGB}{49,175,255}
\definecolor{boxborder}{RGB}{0,0,0}

\usepgfplotslibrary{statistics}
\pgfplotsset{compat=1.18}

\lstset{
  basicstyle=\ttfamily\small,
  breaklines=true,
  frame=single,
  columns=fullflexible
}

\makeatletter
\newcommand{\skipitems}[1]{%
  \addtocounter{\@enumctr}{#1}%
}
\newcommand{\m}{\text{m}}
\newcommand{\dsp}[1]{\displaystyle{#1}}
\makeatother

\title{COMP 3005 Final Project Report}
\author{Afaq Virk, Raymond Liu}
\begin{document}

\begin{flushright}
COMP 3005 A - Fall 2025

Database Management Systems

Final Project Report

Raymond Liu 101264487

Afaq Virk 101338854

\end{flushright}

\section*{Object-Relational Mapping (ORM) Usage}
We used SQLAlchemy's Declarative ORM to map Python classes to relational tables and to express relationships and constraints directly in code. A single shared base class is defined with \texttt{declarative\_base()}, and each entity declares its table name, columns, constraints, and relationships. This allows us to perform type-safe CRUD operations, joins, and cascades using Pythonic APIs instead of writing raw SQL for common operations. Relationships (e.g., one-to-many between \texttt{User} and \texttt{Metric}) are modeled with \texttt{relationship(...)} along with \texttt{back\_populates} for bidirectional navigation, and we use options such as \texttt{cascade="all, delete-orphan"} to enforce lifecycle rules.

The application layer interacts with the database through a SQLAlchemy \texttt{Session}. Typical patterns include querying with \texttt{session.query(...).filter\_by(...).order\_by(...)}; creating domain objects, calling \texttt{session.add(...)} and \texttt{session.commit()}; performing relational joins for cross-entity views; and deleting records with transactional rollback on error. This approach keeps business logic in Python while the ORM translates it into efficient SQL.

\begin{lstlisting}[language=Python, caption={Example SQLAlchemy model mapping}]
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class User(Base):
    __tablename__ = 'user'
    id = Column(Integer, primary_key=True)
    email = Column(String(255), nullable=False, unique=True)
    first_name = Column(String(100), nullable=False)
    last_name = Column(String(100), nullable=False)
    role = Column(Integer, ForeignKey('role.id'), nullable=False)

    role_obj = relationship("Role", back_populates="users")
    metrics = relationship("Metric", back_populates="user",
                           cascade="all, delete-orphan")
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={Typical ORM query/CRUD usage}]
# Recent metrics for a member
recent = (session.query(Metric)
          .filter_by(user_id=user.id)
          .order_by(Metric.logged_date.desc())
          .limit(5)
          .all())

# Create and commit a new metric
new_metric = Metric(user_id=user.id, metric_type=metric_type_id, value=Decimal("72.5"))
session.add(new_metric)
session.commit()

# Join across relationships to see upcoming sessions
upcoming = (session.query(Enrollment)
            .join(Session)
            .join(Schedule)
            .filter(Enrollment.member_id == user.id, Schedule.date >= date.today())
            .order_by(Schedule.date, Schedule.start_time)
            .all())
\end{lstlisting}

\paragraph{Major mapped entities}
\begin{itemize}[nosep]
  \item Role, User
  \item Service, Bill, Item
  \item MetricType, Metric, Goal
  \item Room, EquipmentStatus, Equipment
  \item ScheduleType, Schedule, Session, Enrollment
\end{itemize}

\end{document}
